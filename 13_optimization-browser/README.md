# 브라우저단 최적화

## Caching(HTTP caching)

### 캐시

주어진 리소스의 복사본을 들고 있다가 요청시에 그것을 제공. 웹 캐시가 자신의 저장소 내에
요청된 리소스를 가지고 있다면, 요청을 가로채 원래의 서버로부터 리소스를 다시 다운로드하는 대신
리소스의 복사본을 반환한다

### 웹 캐시의 종류

https://developer.mozilla.org/ko/docs/Web/HTTP/Caching

- private browser cache : 단일 사용자가 전용으로 사용. 브라우저단 캐싱
- shared proxy cache : 한 명 이상의 사용자에 의해 재사용되는 응답을 저장하는 캐시. 캐시 서버, 인메모리 캐시

### 정적 컨텐츠 캐싱

이때 클라이언트에 가까운 것은 프라이빗 캐시 - 브라우저 캐싱  
이미 한번 다운로드 받은 정적 자원들을 컴퓨터의 메모리, 디스크, 프록시 서버, CDN 등등에서 캐싱  
https://medium.com/@codebyamir/a-web-developers-guide-to-browser-caching-cc41f3b73e7c

- 유저가 사이트에 최초 방문 : 캐시된 것이 없으므로 서버에서부터 가져옴. network 하단의 transferred된 바이트
  량 보면 얼마나 많은 데이터가 왔다갔다했는지 알 수 있음(size 표시)
- 이전에 방문한 적이 있다면(캐시에 자원들이 있다면) : 브라우저가 서버에 요청은 보내지만(index.html), 정적 자원들을 서버가 아니라
컴퓨터 내부의 캐시에서 가져온다 (from memory cache, disk cache)
- 어디에서 캐시를 하든 캐시 헤더를 활용하는 느낌

### 갱신

- 리소스에 대한 만료 시간 설정, 만료 시간 이전에는 리소스가 유효함 이후에는 stale
- 캐시가 유효하면 그냥 캐시에있는거 가져다 쓴다
- 캐시가 stale 상태라면(만료시간이 끝났다면) if-None-Match와 함께 요청을 전달하고(Etag 기반하여 갱신 여부를 확인하는 듯)
  서버에서 아직 리소스가 유효한 경우 리소스 본문을 전송하지 않고 304 응답을 돌려보내서 대역폭 절약
    - 이러면 캐시의 만료시간은...? => 갱신되는듯
- max-age 프로퍼티가 헤더에 설정된 경우 이걸 가지고 유효수명을 계산하고, 없으면 Expires를 찾는다
  - Expires는 좀 오래된 헤더인데, 만료가 될 Date 정보를 가지고 있다
- HTML 메타 태그에서도 cache-control 정보를 넣어줄 수 있다. 근데 모든 브라우저가 이를 알아먹을 수 있는건 아니라서 별로 추천은 안댐
- 파일 이름이 바뀌는 경우 해당되는 캐시가 유효하지 않음 => 웹팩 번들 빌드에서 해쉬값을 계속 바꿔서 빌드하는 이유
- 갱신법
  - 퍼지 : 저장소를 완전히 지우는 방식
  - 인밸리데이션 : 조건부 요청을 통해 캐시된 리소스들 중 변경이 있었던 리소스만 새로 갱신
- 캐시키 : 클라이언트가 요청하는 URL. 캐시 서버가 원본의 복사본을 저장하고 바르게 조회하기 위해 사용하는 키값

### 제어 - 캐시 헤더

브라우저는 HTTP 리스폰스의 cache header을 평가하여 캐시를 어떻게 할지 결정한다  
어 근데 s3의 정적 자원같은거는 GET으로 내려받을때 cache header을 어떻게 설정하지? => 먼가 방법이 있겠지 싶음..

- **ETag** : Entity Tag, 원본 서버가 리소스를 식별하기 위해 부여하는 고유 번호. 파일의 해시값. 서버가 응답에 ETag를
  넣어줄 수 있는데, 브라우저는 이 식별자를 가지고 캐시가 stale되었는지 판단한다. (같은 응답에 대해 다른 ETag가 오면?? - invalidation하는? 그런 느낌인가)
  식별자가 같고 자원이 바뀌지 않았을 경우 서버는 304응답(not modified)과 빈 바디를 준다. 브라우저는 304가 오면 캐시에 저장된 자원을 계속 써도 되겠다고 판단한다
    - 콘텐츠 기반의 조건부 요청 : 어떤 요청에 대한 원본 서버의 콘텐츠가 캐시에 저장된 후 변경되었는지 여부를 ETag로 확인하는 방법. 내용이 약간이라도
    수정되면 해시값도 변하기 때문에 이 값을 비교해 컨텐츠의 변경 여부를 잡아낸다
    - 캐시 만료시 If-none-match 헤더에 ETag 값을 복사하여 원본 서버에 전송하면 => 이 콘텐츠와 일치하는 고윳값이 없다면 전체 응답을 다시 주셈
    - 원본 서버는 ETag 값이 같다면 캐시 저장본이 현재 버전과 동일하다 판단해 304응답을 전송하고 캐시를 갱신
- **Cache-Control** : 캐시 동작을 정의하기 위한 헤더
    - public : 모든 캐시 서버에서 캐시될 수 있음(브라우저, CDN 등등 모두)
    - private : 브라우저에서만 캐싱. HTTP 요청에 대한 응답은 요청한 사용자만 캐시할 수 있고 CDN 같은 범용 캐시 서버에서는 캐시할 수 없음
        - cloudFront 설정을 해놓고 cache header을 private으로 가져가면??? => cloudFront에서 캐시 방지가 된다 https://aws.amazon.com/ko/premiumsupport/knowledge-center/prevent-cloudfront-from-caching-files/
    - no-store : 서버가 로컬 저장소(디스크? 메모리?)에 메시지를 저장하지 않도록 지시. 즉 브라우저 캐싱이 이루어지지 않고 서버로 계속 요청을 한다
      다른 캐시 수단이 있어야 사용할 수 있을듯..?
    - no-cache : 캐시된 복사본을 사용자에게 릴리즈하기 전에, 유효성 확인을 위해 원 서버로 요청을 보냄
    - max-age=N : 캐시의 유효기간 설정, s-max-age는 cdn과 같은 공용 캐시 주기 관리
    - must-revalidate : 만료된 리소스는 아예 사용하지 않고 갱신
  

### 동적 컨텐츠 캐싱

- 몇몇 캐시 프록시 서버는 요청 쿠키, 헤더, 쿼리 스트링을 캐시할 수 있다
- Ajax의 경우 : JSON/XML 타입 컨텐츠는 다른 정적 응답 타입과 동일한 방식으로 캐시할 수 있음
  - 캐시 주기를 설정하고 이 시간이 만료된 경우에만 캐시 서버가 원본 서버에서 갱신된 결과를 받아오게 함
  - if-modified-since : 서버가 지정된 시점 이후 수정된 경우에 200, 수정되지 않은 리소스에 대한 요청시 304
  - 서버 캐싱이 어떻게 이루어지는지 살펴봐야할듯.. 인프라에서 어떻게 처리하는지도..
  
결국 인프라단에서 혹은 서버에서 어떤 캐싱 헤더를 끼워넣어서 응답을 보내주는지가 약간 관건 => 인프라랑 섞어서 공부해야할듯

 
## Critical Rendering Path

## Gzip 압축