# 프론트엔드 프로젝트에서 클래스가 필요한 경우는 언제일까

사실 개발 블로그에 쓰고 싶었는데, 이런 고민이 과연 일반적일까? 나만 이런걸 고민했던건 아닐까..? 하는 의문이 들어서 여기다가 먼저 써 본다. 

Draft - 아직 결론을 내리지 못함. 클래스에 대해서 좀 더 공부가 필요하고, 클래스를 사용했을 때 JS 프로젝트에서 어떤 이슈가 나타날지는 좀 더 경험 & 생각해봐야할 것 같음
## 왜 생각해 보았나

서버에서 받아온 데이터는 프론트엔드에서 뷰와 기획에 적합한 형태로 가공을 거쳐 뷰에 표시하게 된다.

이런 로직들을 주로 helper, 혹은 utils라고 많이 일컬어지는데, 나는 주로 Adapter 로직이라고 부르고 싶다. 서버의 데이터를 클라이언트의 화면에 맞게 변환하고 가공하는 과정이기 때문이다.

이러한 어댑터 로직, 함수들을 서버에서 받아온 데이터를 데이터와 함께 동작을 같이 모델링해서 응집도 있는 상태로 유지하면서 쓰면 어떨까 생각이 들었다.
### 생각해본 구현 방식(대충의)

  - 프로젝트에서 서버로부터 받아온 데이터를 적당히 가공하여 View에 필요한 방식으로 만드는 Helper 함수들을 기능 도메인별로 클래스로 묶은 다음
  - Public, Private 등의 접근 제어자로 관리해 다른 함수들과의 관계를 더 잘 표현하고, 기능적 관심사가 같은 함수들을 클래스에 묶어놓으면 관리가 편하지 않을까 했음.
  - 이런 클래스를 만들면, 만약 Redux를 사용할 경우 Reselect에서 인스턴스를 생성하고, Selector을 통해 컴포넌트에서 접근이 가능하게 만들 수 있다. 
  - 이렇게 사용하면 인스턴스 생성을 중앙에서 통제할 수 있어서 데이터가 바뀌기 전까지는 singleton 인스턴스처럼 사용이 가능할 것으로 보았다.
  - Select의 개념이 있는 React Query나 Recoil등을 통해서도 이런 식으로 사용할 수 있다.
  ```js
  // 음식 리스트를 보여주는 도메인에 대한 클래스를 만든다
  class FoodList {

    constructor(list) {
      this.list = list
    }

    get favoriteFood() {
      return ...
    }

    get vegetables() {
      return this.list.map((food) => food.category === 'vegetable');
    }
  }

  // 음식 리스트를 보여주는 기능 도메인을 위한 데이터를 selector로 가져온다
  export const selectFoodList = createSelector(
    [state => state.foodList],
    foodList => new FoodList(foodList)
  );
  ```
  - 이런 방식이 빛을 발하려면, 프로젝트 디렉토리를 페이지 단위나 컴포넌트 단위가 아니라 철저히 [기능 단위로 구분해야한다.](https://ahnheejong.name/articles/package-structure-with-the-principal-of-locality-in-mind/) 그래야 클래스 내부가 비정상적으로 비대해지지 않을 수 있다.
## 생각해본 장점

- 데이터와 함께 로직을 같은 곳에 보관할 수 있어서 코드의 응집도가 높아짐
- 상태 관리 라이브러리의 역할을 클래스로 가져올 수 있음 : 위처럼 클래스로 Select를 할 수 있다면, Reselect를 수정하지 않고 클래스만 수정하면 필요한 데이터를 척척 가공해서 가져올 수 있다. 앱의 복잡성을 낮추는 효과??
- 특정 기능 단위의 모든 컴포넌트에서 모든 함수와 변수에 접근할 수 있게 되므로 로직 개발에 있어 유연함이 생길 수 있다.

## 생각해본 단점

- **기능 도메인으로 클래스를 분리하기 애매할 수 있음** : 기능 도메인을 담당하는 클래스에 어떤 책임을 부여할 것인지에 대한 문제인데, 특정 서버 데이터가 다른 기능에서도 필요하다면 어떻게 가져가야 하는지..? 멤버변수로 서버 데이터 전체를 막 몇 개씩 받아야 하는지? 아니면 필요한 부분만 절삭해와서 selector을 만들어야 하는지..? 이건 내가 근데 객체의 책임과 역할 메시지 교환에 대해서 잘 몰라서 답을 잘 못내리겠음 함 공부해봐야겠다.
  - 이렇게 필요한 데이터를 쓰까? 사용하는게 협업 면에서 좋은가? 커뮤니케이션 비용은?
  - 귀찮은 타입선언이 또 필요하지는 않을까?
- **트리 쉐이킹에 불리함** : [직접 babel, TypeScript 설정하고 트리쉐이킹이 되는지 실험해 봤는데]('../21_bundler-tree-shaking/README.md) Class는 TreeShaking이 되지 않았다. 안 쓰는 메소드도 다 번들에 포함되었다. 기본적으로는 [정적 분석이 어렵기 때문에 클래스, 클래스의 Static 메소드는 트리쉐이킹이 잘 안 된다.](https://blog.logrocket.com/tree-shaking-and-code-splitting-in-webpack/) [이 글](https://medium.com/naver-fe-platform/webpack%EC%97%90%EC%84%9C-tree-shaking-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0-1748e0e0c365)에 따르면 Babel 7부터는 Class에 Pure Annotation을 붙여 트리쉐이킹을 돕는다고 해서 좀 기대해 봤는데 일단 내 실험에서는 트리쉐이킹이 되는 모습을 확인할 수 없었다. 
  - 어떤 상황에서 클래스가 트리쉐이킹 되는거지..?
  - 짜피 트리 쉐이킹은 Dead Code만 없애는 거니까, 클래스의 메서드를 모두 쓸 수 있게 신경써서 개발하되 불필요한 경우에 인스턴스 생성이 되지 않게 잘 제어할 수 있다면 별로 큰 변수가 아닐지도 모른다.
- **클래스의 취지를 잘 살리지 못하는 클래스는 사실 의미없음** : 이거는 단점이라기 보다는 주의사항에 가깝다. 모든걸 무지성으로 클래스로 감쌀 필요는 없다. 클래스는 어떤 객체의 "동작"과 "상태"를 모두 가지면서 해당 객체를 효과적으로 모델링하기 위해 존재하는 개념이다. 
  - 사실 아래와 같은 클래스는 별로 의미가 없다. 함수로 분리하고 가져다 써도 별로 큰 차이가 없다. 만들고자 하는 클래스가 이렇게 생겼다면 필요가 없다.
  ```js
  // 동작만 존재하는 클래스
  class UserInfoHelper() {

    constructor() {}
    
    someMethod1() {
      ...
    }

    someMethod2() {
      ...
    }

    static someMethod2() {
      ...
    }
  }
  ```
  - 특정 상황에서 인스턴스를 먼저 만들고 메소드를 호출하는게 불필요한 동작처럼 느껴질 수도 있다. 굳이 인스턴스를 만드는 시점에서 멤버변수를 인자로 받을 필요가 없다면 더욱더...
- **서버 데이터 같은 경우 오염을 막아주는 도구가 있을 수 있다** : 꼭 접근 제어자로만 데이터의 무결성을 담보할 수 있는걸까? Redux같이 불변성을 보장하는 빡센 상태관리 도구를 사용하고, 인스턴스 생성을 제한적인 상황에서만 가능하게 하면 액션을 정의하지 않는 이상 Store의 원본 데이터를 수정할 수 없을 것이다. 
  - 클래스를 안 쓰는 것보다 클래스를 잘 못 만든다면 이런 Mutation 이슈가 생길수도 있다.
- **Private 메서드도 테스트하고 싶은 상황이 생기지 않을까?** : 물론 제어 흐름상 public한 메서드에서 private한 메서드가 호출될 것이므로 public 메서드를 테스팅하면 얼추 private 메서드까지 테스팅할 수 있겠지만, private을 테스트하는게 테스트 케이스를 더 효과적으로 작성할 수 있는 방법이 되는 상황도 있을 수 있다. 굳이 제약을 걸어서 테스트의 가능성을 좁히는 일이 과연 타당할까? - 이건 근데 Java 진영에서도 요거 비슷한 고민을 하지 않을까? 아니면 애초에 그럴 일이 없게 설계를 해야하는 걸까? 함 알아보자
- **사실... 모든 함수가 호출 가능해야만 하는 상황이 있을까?** : 클래스 인스턴스를 만들면 그 시점부터 인스턴스를 가지고 내부의 모든 함수들을 호출 가능하다. 그런데 프론트엔드 프로젝트에서 Helper 함수들은 굳이 모든 헬퍼 함수들이 모든 상황에서 호출될 수 있게끔 만들 필요가 없을 수 있다. 
  - 모든 Helper 함수들은 저마다의 용례를 가지고 있기 때문에 만들어진 친구들이다. 필요한 상황과 장소에서만 쓰이기 때문에 Named export로 가져와서 적제적소에 코딩을 해주는게 낫지 않을까 하는 생각이 있다. 굳이 많은 함수들이 인스턴스 안에 들어가 호출을 기다릴 필요가 없지 않을까? 오버킬이 아닌가..?

## 클래스가 필요할 수 있는 경우

### 1. 메소드 체이닝을 활용하면서 개발자에게 자율권을 주는 라이브러리를 만드는 경우

- 어떤 라이브러리가 여러 메소드를 자유롭게 이용할 수 있는 자율권을 부여하여 개발자의 목적을 달성하게 만드는 라이브러리라면, 그런 측면에서는 클래스가 의미가 있을 수 있다.
- 특히 클래스로 객체를 만들면 **메서드 체이닝**을 사용할 수 있고, 체이닝으로 연달아 호출하는 로직을 선택하는 것을 라이브러리 사용자의 몫으로 만들고 싶다면 클래스를 사용하는 것이 적합할 수도 있다.
- 다만 꼭 클래스를 통해서만 자율권을 부여할 수 있는 것은 아니다. RxJS의 접근 방식이 그걸 보여준다.

```js
// obs.pipe(op1(), op2(), op3(), op4());
import { first, last, map, reduce, find, skipWhile } from 'rxjs/operators';
observable.pipe(
    map(x => {return x}),
    first()
  ).subscribe(x => {})
```
- RxJS의 Observable은 메서드 채이닝으로 pipe와 subscribe메소드를 연달아 호출할 수 있지만, pipe는 여러 연산자를 인자로 받아 함수형으로 데이터를 처리한다. pipe 메소드는 연산자를 인자로 받는 형식으로 사용자에게 자율권을 준다.
- 모든 메소드를 observable 클래스 안에 구현하지 않는 방법을 택함으로써 연산의 확장 가능성을 담보한 것이다.

### 2. 복잡한 속성과 동작을 객체로 모델링해야할 필요가 생기는 경우

- 이건 진짜 클래스의 취지를 제대로 살릴 수 있는 경우다.
- 완전 새로운 타입이 필요한 경우라고도 할 수 있겠다.
- 인터랙티브 웹 개발을 예로 들 수 있겠는데. 해커톤에 참여했을 때 웹 게임을 만든 적이 있는데 게임에 등장하는 개체들을 클래스로 정의한 것이 복잡한 로직을 정리하여 효과적으로 개발하는데 도움이 많이 되었다.

### 3. 클래스를 프레임워크의 인터페이스로 활용하는 경우

- 프레임워크 개발에 클래스를 사용하면 implment, 상속 등으로 기능을 여러 레벨로 추상화할 수 있어 탄탄한 설계를 가진 프레임워크가 될 수 있다.
- 프레임워크 사용하는 개발자에게 클래스를 작성하는 방식으로 앱을 만들 수 있게 하는 프레임워크라면, 작성을 해야만 하는 약속된 메서드, 데코레이터 등의 기능을 이용하여 프레임워크 사용자들에게 상당히 많은 정보와 신뢰성을 제공할 수 있다.
  - 당장 React Class 컴포넌트를 생각해봐도 constructor에 state와 prop을 정의하는 방식, render() 메소드, 생명주기 등 많은 부분들이 문법적으로 미리 정해져있고 사용자가 이를 따르게끔 할 수 있었다.
  - 그에비해 함수형은 Hooks는 그냥 함수라서 사실 자유롭게 호출할 수 있다. 하지만 side-effect를 발생할 여지가 높기 때문에 hook rule 등을 적용해 에러를 발생시키고 있지만, **문법이 틀린 것은 아니다**
- 개발자는 작성만 하고 인스턴스의 생성과 실행을 프레임워크가 담당하고 위임하는 방식이라면 개발자는 만든 클래스를 어떻게 설계하고 사용할지 골머리를 앓지 않아도 된다.
- Angular나 Nest.js가 이런 클래스 기반의 인터페이스를 제공하는 프레임워크에 해당된다.

# 결론

- 클래스는 적시에 사용하면 유용한 도구가 될 수 있다.  
- 무지성으로 모든 모듈을 클래스로 감쌀 필요는 없다.
- 공부를 좀 더 해보고 조언도 구해보자ㅜㅜ