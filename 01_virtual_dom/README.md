# React의 심장, virtual DOM

## [리액트 엘리먼트](https://ko.reactjs.org/docs/rendering-elements.html)

```jsx
const element = <h1>Hello, world</h1>;

// 돔 노드 렌더링
ReactDOM.render(element, document.getElementById("root"));
```

- **React element는 불변객체**, 엘리먼트를 생성한 이후에는 해당 엘리먼트의 자식이나 속성을 변경할 수 없음. 엘리먼트는 영화에서 하나의 프레임과 같이 특정 시점의 UI를 보여줌
- UI를 업데이트하는 유일한 방법은 새로운 element 생성하고, 이를 ReactDOM.render()로 전달하는 것
- 변경된 부분만 업데이트 : React DOM은 해당 엘리먼트와 그 자식 엘리먼트를 이전의 엘리먼트와 비교하고, DOM을 원하는 상태로 만드는데 필요한 경우에만 DOM을 업데이트한다. => 상태가 바뀌었을 때 개발자 도구를 사용해서 업데이트 양상 살펴보기

```jsx
// 인터벌로 매초 render을 실행하지만, 개발자 도구로 살피면 업데이트가 되는 부분만 바뀜
function tick() {
  const element = (
    <div>
      <h1>Hello, world!</h1>
      <h2>It is {new Date().toLocaleTimeString()}.</h2>
    </div>
  );
  ReactDOM.render(element, document.getElementById("root"));
}

setInterval(tick, 1000);
```

- 엘리먼트 렌더링에서의 state: **render을 캡슐화.** 이 컴포넌트에 한해서는 스스로 타이머를 설정하고, 매초 스스로 업데이트하게 만드는 것 => 하위 컴포넌트 안에서의 state 변경은 render을 호출하게 만든다
- 하향식, 단방향식 데이터 흐름 : 모든 state는 항상 특정한 컴포넌트가 소유하고 있으며, 그 state로부터 파생된 UI또는 데이터는 오직 트리구조에서 자신의 아래에 있는 컴포넌트에만 영향을 미치게 됨.

## [재조정(Reconciliation)](https://ko.reactjs.org/docs/reconciliation.html)

- state나 prop이 갱신되면 render() 함수는 새로운 React 엘리먼트 트리를 반환할 것 => 이때 React는 방금 만들어진 트리에 맞게 가장 효과적으로 UI를 갱신하는 방법을 알아낼 필요가 있음
- 하나의 트리를 가지고 다른 트리로 변환하기 위한 연산수를 구하는 알고리즘 => 대충 O(n^3) 정도의 무지느린 성능을 지님
- React에 이 알고리즘을 적용하면, 1000개의 엘리먼트를 그리기 위해 10억번의 비교연산을 수행해야함. 너무나 비쌈. React는 대신, 두가지 가정을 기반하여 O(n) 복잡도의 휴리스틱 알고리즘을 구현
  1. 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어냄
  2. 개발자가 key prop을 통해 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해 줄 수 있다 => key가 바뀌면 렌더링

### 비교 알고리즘

- **두 루트 elem의 타입이 다르면** React는 이전 트리를 버리고 완전히 새로운 트리를 구축.
- 트리를 버리면 이전 DOM 노드들은 모두 파괴 => 생명주기로 따지면 돔 노드들이 파괴될때 unmount 실행, 새로운 노드는 willMount, DidMount 실행
- 안에 있었던게 동일해도 루트 elem 태그가 다르면 그 안에있는것도 다 사라지고 처음부터 다시 마운트
- **타입이 같으면** 두 엘리먼트의 속성을 확인하여 동일한 내역은 유지하고 변경된 속성들만 갱신. 여기서 속성은 className같은거..
- DOM노드 처리가 끝나면 React는 이어서 해당 노드의 자식들을 재귀적으로 처리
- 컴포넌트 갱신시 인스턴스는 동일하게 유지되어 렌더링간 state가 유지. React는 새로운 엘리먼트의 내용을 반영하기 위해 현재 컴포넌트 인스턴스의 prop을 갱신

### keys를 쓰는 이유

- 동일 돔 노드의 자식들을 재귀적으로 처리할때 React는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경을 생성함
- 자식의 끝에 엘리먼트를 추가하면 두 트리 사이의 변경은 잘 작동함(일치하는 것 계속 확인 가능). 하지만 맨 앞에 추가하는 경우 다 달라버리기 때문에 모두 새로 그리는 불상사가 일어남
- 자식들이 key를 가지고 있다면, React는 key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인함.(key가 동일한 것끼리 비교함). key는 형재 사이에서 유일하면 됨
- 배열의 인덱스를 key로 사용하는 것은 피해야함. 배열 자체에서 만약 항목들이 재배열되지 않는다면 잘 작동하지만, 배열이 완전 재배열되는 경우 비효율적으로 작동함

- 인덱스를 키로 사용할때 배열이 재배열되면 컴포넌트의 state와 관련된 문제가 발생 가능. 컴포넌트 인스턴스는 key를 기반으로 갱신되고 재사용됨. 인덱스를 Key로 사용하면, 항목의 순서가 바뀌면 key또한 바뀌기 때문. 그 결과로 컴포넌트의 state가 엉망이 되거나 [의도하지 않은 방식으로 바뀔 수 있음](https://ko.reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key)

## 컴포넌트 렌더링하면 생기는 모든 일

- state 업데이트는 비동기적일 수 있음 => 업데이트 실패하는 경우?
- hook 기반 리액트에서는 컴포넌트 렌더링 이후 useEffect 일괄적으로 실행(state가 바뀜 -> 재랜더링 -> 재랜더링 과정에서 컴포넌트 내부 변수, 함수 다시 만들어짐 -> useEffect 실행 -> 재랜더링 이하 어느 과정에서 state가 또 바뀐다면 다시 재랜더링 -> 함수변수 다시 만들어짐...)
- 최적화
  - useMemo, useCallback : 재랜더링 과정에서 함수를 다시 만들어지지 않게 해줌
  - useRef : 랜더링을 유발하지 않는 고정 메모리값
  - 일단 useState를 최소한으로 선언해야함 => state는 진짜로 컴포넌트 렌더링에 필수적인 값들이어야 함
