# fiber

React 16의 새로운 재조정(reconcilation) 엔진.

## [motive](https://codesquad-yoda.medium.com/%EB%82%A8%EB%8B%A4%EB%A5%B8-%EA%B0%9C%EC%84%A0%EB%B0%A9%EB%B2%95%EC%9D%84-%EB%8B%A4%EC%8B%9C-%EB%B3%B4%EC%97%AC%EC%A4%80-%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81%EC%9D%98-react-fiber-80b7ca5bd9bb)

- 렌더링 방식의 문제. 리액트 자체가 무언가 처리하는 시간을 단축시키지는 못함. 오히려 lifeCycle이나 잦은 리렌더링이 호출될 수 있는 구조이기 때문에 실제로 타임라인 탭에서 콜스택 보면 깊이에 놀라버림
- 리액트는 브라우저에 최종적으로 돔을 그리는 작업을 최소화하게는 해주지만, 스레드는 여전히 node라 하나이므로, 스레드 부하가 강하게 걸리는 복잡한 애니메이션과 연산작업이 섞여있다고 해서 가상돔이 문제를 해결해주지는 못함
- 만약 setInterval을 통해 초단위로 많은 DOM의 변화를 발생시킨다면..? 애니메이션 처리가 DOM을 처리하느라 스케쥴이 빼곡한 stack공간에 들어가기까지 많은 시간을 대기해야 하므로 60fps를 못맞추게 됨.
- 리액트는 이전에 렌더링을 한번 시작하면 중간에 멈출 수 없었기 때문에 진짜 렌더링할 것들이 많은 경우에 사용자의 마우스 이벤트나 키보드 이벤트에 거의 반응할 수 없었음.=> 선점형 멀티태스킹으로 이 문제를 해결
- 비동기로 처리되는 애니메이션 작업이 반복적으로 이루어지는 DOM 조작에 밀려서 생기는 우선순위 문제. 싱글 스레드 환경에서는 당연한 일. 연속적으로 애니메이션을 처리할때 DOM 조작은 자제해야함

## 해결책

- 파이버는 렌더링 과정을 여러개의 작업으로 나눠서 실행 중인 작업을 중단하거나 중단된 작업을 재개할 수 있다. 실행 중인 작업을 중단하는 판단의 기준은 크게 두가지 - 작업이 일정 시간을 초과하거나, 현재 실행중인 작업보다 우선순위가 더 높은 작업이 들어오면 현재 작업을 중단함.
- requestIdleCallback : 특정 잔여 시간을 기준으로 어떠한 일을 더 할지 안할지를 결정할 수 있음. 어떠한 작업이 시간내에 이뤄지는지를 판단해서 계속, 그만을 결정할 수 있음 => virtual stack frame
- fiber는 동작중인 리액트 코드를 매번 부르고, 주어진 시간을 초과한다면 멈추고 중요한 일에 더 양보 => 운영체제의 선점형 멀티태스킹 개념 : 하나의 프로그램이 CPU를 점유하지 못하도록 하기 위해 일정 시간이 지나면 실행을 멈추고 다른 프로그램을 실행 == 프로그램의 현재 상태를 저장하고 나중에 다시 실행될때 이전 상태를 복원할 방법이 필요.

## 실질적인 특징과 구현

파이버 미적용  
![파이버 미적용](https://miro.medium.com/max/1400/1*uSB0-9AgurJQ0cZrXIduyw.jpeg)

파이버 적용  
![파이버 적용](https://miro.medium.com/max/1400/1*nvb6r8wrPCDV0j1CzWT-Uw.jpeg)

- task를 더 잘게 쪼갠다
- DOM의 실제 변화를 두기 전인 재조정 단계에서 처리된다
- 부하가 높고 DOM과 애니메이션이 난립하는 rich UI의 경우에만 의미가 있음.
- 잘못된 코드패턴으로 render가 너무 자주 불러지거나, 비동기로 인해 느려지는 초기 렌더링 이라던가, 연산과정이 너무 복잡해서 렌더링까지 걸리는 시간이 오래 걸린다거나 하는 문제까지 해결해준다고 볼수 없음
- 개선의 초점 : fiber의 개선이 사용자의 UX개선에 초점이 맞춰져 있다는 점에서 매우 고무적. 개발 생산성이라는 프레임워크의 장점뿐 아니라,,
- 현재 실험적 기능으로 제공하고는 있다

## 작업의 우선순위

- 렌더링 작업별 우선순위는 그러면 어떻게 되는가? => 아직 윤곽이 잡히지는 않았는데, 대충 컴포넌트 상태값 변경시 직접 우선순위 입력하거나, 이벤트 처리 함수별로 리액트가 자동으로 우선순위를 결정하거나(onEvent사이라던가), 혹은 화면에 보이지 않는 영역은 우선순위를 낮게 해서 나중에 처리하거나 할거

## 서스펜스/캐시 - 리액트의 실험적 기능

- 비동기 렌더링에 관련한 거라면 이것도 빠질 수 없음
- 렌더링 과정에서의 비동기 처리 지원
- 비동기로 모듈 처리(익히 알고있는 기능, lazy, suspense)
- Suspense로 렌더링 중 API 호출하기(?!!?1?!)
  - fallback 컴포넌트가 계속 보여졌다가 비동기가 끝나면 다시한번 렌더링되는 느낌
  - react-cache : 렌더링 과정에서의 비동기 처리를 지원하기 위해 리액트에서 제공되는 실험적 패키지. 정식으로 지원은 아직 안됨
  - read를 호출했을 때 이미 받은 데이터가 있다면 그 데이터를 사용하고, 없으면 fetch를 해오고 fetch함수가 반환하는 프로미스 객체와 함께 예외를 발생시킴. 예외가 발생하면 부모로 거슬러 올라가면서 가장 가까운 Suspense 컴포넌트를 찾음. Suspense 컴포넌트는 내부 영역을 fallback으로 처리하고, 추후 프로미스가 처리됨 상태가 되면 다시 렌더링
  - 뭔가 좀더... 쫀득쫀득한 방법인 것 같다는 생각이 듬. 렌더링과 딱! 붙어서 예외처리를 해버리기..
